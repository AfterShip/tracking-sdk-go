// Code generated by AfterShip SDK Generator. DO NOT EDIT.

package component

import (
	"encoding/json"
	"github.com/aftership/tracking-sdk-go/v4/errorx"
	"io"
	"math"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"time"
)

type response struct {
    Data interface{} `json:"data,omitempty"`
    Meta meta        `json:"meta,omitempty"`
}

type meta struct {
    Code    int    `json:"code,omitempty"`
    Message string `json:"message,omitempty"`
    Type    string `json:"type,omitempty"`
}

type Config struct {
	UserAgent string
	Domain    string
	Timeout   int64
	MaxRetry  int
	Proxy     string
}

type HttpSender struct {
	httpclient *http.Client
	auth       *Authenticator
	rateLimit  *RateLimit
	Config
}

func NewHttpSender(config Config, auth *Authenticator) *HttpSender {
	client := http.Client{
		Timeout: time.Duration(config.Timeout) * time.Millisecond,
	}
    if len(config.Proxy) > 0 {
        proxyUrl, _ := url.Parse(config.Proxy)
        client.Transport = &http.Transport{
            Proxy: http.ProxyURL(proxyUrl),
        }
    }
	return &HttpSender{
		httpclient: &client,
		auth:       auth,
		rateLimit:  &RateLimit{},
		Config:     config,
	}
}

func (c *HttpSender) Do(request *http.Request, data interface{}) error {
	var err error
	request = c.setParam(request)
	request.Header, err = newHeaderBuilder(c.auth).
		buildDefaultHeader(c.UserAgent).
		buildAuthHeader(request).
		build()
	if err != nil {
		return errorx.NewSdkError(errorx.ErrBadRequest, errorx.GetErrorMessage(errorx.ErrBadRequest), err.Error())
	}

	if c.isRateOverflow() {
		return errorx.NewSdkError(errorx.ErrRateLimitExceed, errorx.GetErrorMessage(errorx.ErrRateLimitExceed), "")
	}

    var resp *http.Response
    resp, err = c.httpclient.Do(request)
    if err == nil {
        defer resp.Body.Close()
    }
    setRateLimit(c.rateLimit, resp)

	if c.shouldRetry(resp, err) {
		retryResp, errRetry := c.retry(request, err)
        if os.IsTimeout(errRetry) {
            return errorx.NewSdkError(errorx.ErrTimeout, errorx.GetErrorMessage(errorx.ErrTimeout), err.Error())
        }
		if errRetry != nil {
			return errorx.NewSdkError(errorx.ErrBadRequest, errorx.GetErrorMessage(errorx.ErrBadRequest), err.Error())
		}
		return c.parseResponse(retryResp, data)
	}

    return c.parseResponse(resp, data)
}

func setRateLimit(rateLimit *RateLimit, resp *http.Response) {
	if rateLimit == nil || resp == nil || resp.Header == nil {
		return
	}
	if reset := resp.Header.Get("x-ratelimit-reset"); reset != "" {
		if n, err := strconv.ParseInt(reset, 10, 64); err == nil {
			rateLimit.Reset = n
		}
	}

	if limit := resp.Header.Get("x-ratelimit-limit"); limit != "" {
		if i, err := strconv.Atoi(limit); err == nil {
			rateLimit.Limit = i
		}
	}

	if remaining := resp.Header.Get("x-ratelimit-remaining"); remaining != "" {
		if i, err := strconv.Atoi(remaining); err == nil {
			rateLimit.Remaining = i
		}
	}
}

func (c *HttpSender) retry(req *http.Request, rawErr error) (*http.Response,error) {
    var (
        err error
        respRetry *http.Response
    )
    for i := 0; i < c.Config.MaxRetry; i++ {
        respRetry, err = c.httpclient.Do(req)
        if err == nil && c.isResponseOk(respRetry.StatusCode) {
            return respRetry,nil
        }
        time.Sleep(time.Duration(c.delay(i)) * time.Second)
    }
    return nil, err
}

func (c *HttpSender) shouldRetry(rawResp *http.Response, rawErr error) bool {
	if os.IsTimeout(rawErr) || (rawResp != nil && rawResp.StatusCode >= 500) {
		return true
	}
	return false
}

func (c *HttpSender) parseResponse(resp *http.Response, data interface{}) error {
    if resp == nil {
        return errorx.NewSdkError(errorx.ErrBadRequest, errorx.GetErrorMessage(errorx.ErrBadRequest), "response is empty")
    }
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return errorx.NewApiError(errorx.ErrUnknown, resp.StatusCode, errorx.GetErrorMessage(errorx.ErrUnknown), string(b))
	}
	var response response
	response.Data = data
	err = json.Unmarshal(b, &response)
	if err != nil {
		return errorx.NewApiError(response.Meta.Code, resp.StatusCode, response.Meta.Message, string(b))
	}
	if !c.isResponseOk(resp.StatusCode) {
		return errorx.NewApiError(response.Meta.Code, resp.StatusCode, response.Meta.Message, string(b))
	}
	if response.Meta.Code > 300 {
		return errorx.NewApiError(response.Meta.Code, resp.StatusCode, response.Meta.Message, string(b))
	}
	return nil
}

func (c *HttpSender) delay(retryAttempt int) int {
	delayBase := 3
	delay := delayBase * (2 ^ (retryAttempt - 1))
	jitter := float64(delay) * (rand.Float64() - 0.5)
	tmp := int(math.Max(1, float64(delay)+jitter))
	return tmp
}

func (c *HttpSender) isRateOverflow() bool {
	if c.rateLimit != nil {
		return c.rateLimit.isExceeded()
	}
	return false
}

func (c *HttpSender) isResponseOk(code int) bool {
	if code >= http.StatusOK && code < http.StatusMultipleChoices {
		return true
	}
	return false
}

func (c *HttpSender) setParam(request *http.Request) *http.Request {
	u, _ := url.Parse(c.Domain + request.URL.RequestURI())
	request.URL = u
	return request
}
